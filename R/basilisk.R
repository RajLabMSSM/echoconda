#' Create conda env: basilisk
#' 
#' Create conda env using one of several methods.
#' @param pkgs data.table with the columns:
#' \itemize{
#' \item{"package" : }{Package names.}
#' \item{"version" : }{Package versions.}
#' \item{"channel" : }{Channel where the package was installed from.}
#' }
#' This table can be generated by \link[echoconda]{env_to_yaml} function.
#' @param start Execute \link[basilisk]{basiliskStart} 
#' to build the actual environment.
#' 
#' @source \href{https://github.com/LTLA/basilisk}{GitHub repo}
#' @source \href{https://doi.org/doi:10.18129/B9.bioc.basilisk}{Bioconductor}
#' @returns An object of class \link[basilisk]{BasiliskEnvironment}. 
#' 
#' @keywords internal
#' @inheritParams yaml_to_env
create_env_basilisk <- function(yaml_path,
                                pkgs,
                                sep="=",
                                start = TRUE){  
    package <- NULL;
    # yaml_path <- tail(ymls$yaml_path,1)
    yaml_txt <- yaml::read_yaml(file = yaml_path) 
    deps <- unlist(yaml_txt$dependencies)
    #### Check for pip deps ####
    has_pip <- if(!is.null(names(deps))){
        startsWith(names(deps),"pip")
    } else {rep(FALSE,length(deps))}
    #### Remove version numbers ####    
    deps <- stringr::str_split(deps,"=|>|<",
                               simplify = TRUE)[,1] 
    #### Remove deps that aren't available on Windows ####
    ## (at least, for specific versions)
    if(basilisk.utils::isWindows()){
        deps <- deps[!deps %in% c("wget","gzip","htslib","axel")]
    }
    #### Subset to only core packages #### 
    ## Split by pip / non-pip 
    pip_pkgs <- pkgs[package %in% unname(deps[has_pip]),]
    nonpip_pkgs <- pkgs[package %in% unname(deps[!has_pip]),]
    #### Create basilisk env object ####
    envObj <- basilisk::BasiliskEnvironment(
        envname = yaml_txt$name, 
        pkgname = "echoconda",
        ## Use >= rather than = or == for increased flexibility,
        ## but reduced reproducibility.
        packages = paste(nonpip_pkgs$package,nonpip_pkgs$version,sep=sep),
        pip = paste(pip_pkgs$package,pip_pkgs$version,sep=sep),
        channels = unique(c(pkgs$channel,"nodefaults"))
    ) 
    if(isTRUE(start)){
        proc <- basilisk::basiliskStart(env = envObj)
    }
    return(envObj)
}



#' Get echoR 
#' 
#' Get the echoR conda env
#' @param mini Use echoR mini.
#' @importFrom basilisk BasiliskEnvironment
#' @importFrom data.table fread
#' @importFrom yaml read_yaml
#' @importFrom stringr str_split
#' @keywords internal
get_echoR <- function(mini=TRUE){
    
    #### Import yaml ####
    yaml_path <- system.file(
        package = "echoconda",
        if(isTRUE(mini)) "conda/echoR_mini.yml" else "conda/echoR.yml"
    ) 
    #### Import version numbers using pre-existing conda env ####
    # conda_env <- echoconda::yaml_to_env()
    # pkgs <- reticulate:::conda_list_packages(envname = conda_env)
    #### pkgs <- basilisk::listPackages(env = "echoR")
    # data.table::fwrite(pkgs, "inst/conda/echoR_versions.tsv.gz", sep = "\t") 
    pkgs <- data.table::fread(
        system.file(package = "echoconda","conda/echoR_versions.tsv.gz")
    )  
    echoR <- create_env_basilisk(yaml_path = yaml_path,
                                 pkgs = pkgs, 
                                 start = FALSE)
    return(echoR)
}

echoR <- get_echoR()
